# План разработки игры (Версия 0.01)

## Цель
Разработать прототип ASCII-игры на C# с использованием библиотеки Raylib.

## Этапы разработки:

1.  **Инициализация проекта и настройка Raylib:**
    *   Создание нового консольного проекта C#.
    *   Установка и настройка библиотеки Raylib (через NuGet-пакет `Raylib-cs`).

2.  **Создание базового окна игры:**
    *   Инициализация окна Raylib с заданными размерами и заголовком.

3.  **Реализация основного игрового цикла:**
    *   Обработка событий (ввод пользователя).
    *   Обновление состояния игры.
    *   Отрисовка игровых элементов.

4.  **Настройка отрисовки базовой ASCII-графики:**
    *   Использование шрифтов, способных отображать ASCII-символы.
    *   Отрисовка символов и строк с заданными координатами и цветом.

5.  **Создание и отображение персонажа игрока:**
    *   Определение класса/структуры для персонажа игрока (позиция, символ, цвет).
    *   Отрисовка персонажа на экране.

6.  **Реализация обработки ввода с клавиатуры для перемещения персонажа:**
    *   Обработка нажатий клавиш (например, стрелки или WASD) для изменения позиции персонажа.

7.  **Создание простой статической карты с использованием ASCII-символов:**
    *   Определение структуры данных для карты (например, двумерный массив символов).
    *   Отрисовка карты на экране.

8.  **Реализация базового обнаружения столкновений персонажа с картой:**
    *   Проверка возможности перемещения персонажа в новую позицию на основе карты (например, нельзя пройти сквозь 'стены').

## Статус разработки

*   **Версия 0.01:** Завершена.

---

# План разработки версии 0.02: Внедрение ИИ-управления и переключения режимов

**Цель:** Добавить в игру возможность управления персонажем с помощью искусственного интеллекта (ИИ), а также предоставить пользователю механизм для переключения между ручным управлением и автоматическим управлением ИИ.

**Ключевые особенности версии 0.02:**
*   Возможность игрового ИИ брать на себя управление персонажем.
*   Сохранение функциональности ручного управления.
*   Механизм переключения между ручным и ИИ-управлением во время игры.

---

### Подробный план реализации:

**Шаг 1: Определение интерфейса контроллера**
*   **Действие:** Создать новый файл `IPlayerController.cs`.
*   **Содержимое:** Определить интерфейс `IPlayerController` с единственным методом:
    ```csharp
    public interface IPlayerController
    {
        void Update(Player player, GameMap map);
    }
    ```
*   **Назначение:** Этот интерфейс позволит унифицировать взаимодействие с различными типами контроллеров (ручным и ИИ) в игровом цикле.

**Шаг 2: Реализация ручного контроллера**
*   **Действие:** Создать новый файл `ManualPlayerController.cs`.
*   **Содержимое:** Создать класс `ManualPlayerController`, который реализует `IPlayerController`. В его методе `Update` будет инкапсулирована текущая логика обработки ввода с клавиатуры для перемещения игрока.
*   **Назначение:** Отделение логики ручного управления от основного игрового цикла и соответствие модульной структуре.

**Шаг 3: Реализация контроллера ИИ**
*   **Действие:** Создать новый файл `AIPlayerController.cs`.
*   **Содержимое:** Создать класс `AIPlayerController`, который также реализует `IPlayerController`. В его методе `Update` будет реализована базовая логика ИИ.
    *   **Первая итерация логики ИИ:** Простое случайное движение. ИИ будет случайным образом выбирать одно из четырех направлений (вверх, вниз, влево, вправо) и пытаться переместить игрока, проверяя наличие стен на `GameMap`.
    *   **Механизм задержки:** Добавить небольшую задержку между действиями ИИ (например, движение раз в 10-20 кадров), чтобы его действия не были слишком быстрыми и хаотичными.
*   **Назначение:** Внедрение автономного управления персонажем с помощью ИИ.

**Шаг 4: Модификация основного игрового цикла (`Program.cs`)**
*   **Действие:** Изменить существующий файл `Program.cs`.
*   **Изменения:**
    *   Создать экземпляры `ManualPlayerController` и `AIPlayerController`.
    *   Объявить переменную `IPlayerController currentController`, которая будет указывать на активный контроллер (по умолчанию `ManualPlayerController`).
    *   Добавить логику для обработки новой клавиши (например, `KeyboardKey.KEY_A` или `KeyboardKey.KEY_SPACE`) для переключения значения `currentController` между `ManualPlayerController` и `AIPlayerController`.
    *   В основном игровом цикле `while (!Raylib.WindowShouldClose())` удалить прямую обработку ввода игрока и вместо этого вызывать `currentController.Update(player, gameMap)`.
*   **Назначение:** Интеграция нового подхода к управлению и предоставление пользователю возможности переключения режимов.

**Шаг 5: Обновление класса `Player.cs` (если потребуется)**
*   **Действие:** Провести ревизию `Player.cs`.
*   **Изменения:** Внести изменения только в случае, если выявятся новые требования или оптимизации, связанные с интеграцией контроллеров. На текущий момент ожидается, что изменения не потребуются.

**Шаг 6: Разработка и запуск тестов**
*   **Действие:** Создать новые тестовые файлы и добавить в них юнит-тесты.
*   **Тесты для `ManualPlayerController`:**
    *   `tests/GGD.Tests/ManualPlayerControllerTests.cs`
    *   Проверить, что контроллер корректно обрабатывает различные нажатия клавиш и вызывает метод `player.Move` с соответствующими параметрами.
*   **Тесты для `AIPlayerController`:**
    *   `tests/GGD.Tests/AIPlayerControllerTests.cs`
    *   Проверить, что ИИ-контроллер пытается переместить игрока (можно использовать заглушки или моки для `Player` и `GameMap`).
    *   Убедиться, что ИИ не пытается пройти сквозь стены, используя информацию от `GameMap`.
*   **Назначение:** Обеспечение качества кода и корректности работы нового функционала.

---

### Решение проблем с тестами (важные исправления)
*   **Обновление синтаксиса NUnit `Assert`:** В NUnit версии 4.2 (и выше) статические методы `Assert.AreEqual` и `Assert.AreNotEqual` были удалены. Они были заменены на более гибкий синтаксис с использованием `Assert.That(actual, Is.EqualTo(expected))` и `Assert.That(actual, Is.Not.EqualTo(expected))`. Все вызовы `Assert.AreEqual` и `Assert.AreNotEqual` в `ManualPlayerControllerTests.cs` и `AIPlayerControllerTests.cs` были заменены на новый синтаксис.
*   **Корректировка размера карты в `GameMap.cs`:** Исходный размер карты в `GameMap.cs` (40x20) не соответствовал предположениям существующих тестов, которые рассчитывали на карту 20x10. Размеры `_mapWidth` и `_mapHeight` в `GameMap.cs` были уменьшены до 20 и 10 соответственно, чтобы обеспечить корректную работу граничных проверок в тестах.

---

**Завершение:**
После успешного выполнения всех шагов и прохождения тестов, версия 0.02 будет готова.

---

# План разработки версии 0.03: Процедурная генерация мира, ресурсы и базовое строительство

**Цель:** Заложить фундамент для Minecraft-подобной механики, позволив игроку исследовать процедурно генерируемый мир, добывать ресурсы и использовать их для базового строительства. Расширить возможности ИИ-контроллера для взаимодействия с этими новыми механиками.

**Ключевые особенности версии 0.03:**
*   Процедурно генерируемая карта с различными типами тайлов (ресурсами).
*   Система инвентаря для хранения ресурсов.
*   Действия игрока: "добыча" ресурсов и "строительство" блоков.
*   Простейший HUD для отображения инвентаря.
*   Расширенный ИИ-контроллер, способный выполнять действия добычи и строительства, а также видимость его действий.
*   Возможность изменения размера окна и полноэкранного режима игры.

---

### Подробный план реализации:

**Шаг 1: Возможность изменения размера окна и полноэкранного режима**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения:**
    *   Установить флаг `Raylib_cs.ConfigFlags.FLAG_WINDOW_RESIZABLE` при инициализации окна.
    *   Реализовать логику переключения полноэкранного режима по нажатию клавиши `F11` (используя `Raylib.ToggleFullscreen()`, `Raylib.GetMonitorWidth()`, `Raylib.GetMonitorHeight()`, `Raylib.SetWindowSize()`).
    *   Реализовать динамический расчет `charSize` в цикле отрисовки, чтобы размер символов масштабировался в соответствии с размером окна (например, `charSize = screenHeight / GameMap.MapHeight`).
*   **Назначение:** Улучшение пользовательского опыта, адаптация игры к различным разрешениям экрана.

**Шаг 2: Процедурная генерация карты**
*   **Действие:** Модифицировать `GameMap.cs` и создать `ResourceTile.cs`.
*   **Изменения в `ResourceTile.cs` (новый файл):**
    *   Создать класс `ResourceTile` с публичными свойствами: `char DisplayChar`, `Raylib_cs.Color TileColor`, `string ResourceType` (например, "Stone", "Iron", "Wood"), `int Health` (сколько "ударов" нужно для добычи).
*   **Изменения в `GameMap.cs`:**
    *   Сделать `_mapWidth` и `_mapHeight` публичными статическими константами (`public const int MapWidth`, `public const int MapHeight`).
    *   Удалить метод `InitializeMap()`, который создает статическую карту.
    *   Создать новый метод `GenerateMap()`, который будет процедурно генерировать карту.
    *   Изменить внутреннее хранилище карты: вместо `char[,] _map` использовать `MapCell[,] _mapCells` (где `MapCell` - новый класс/структура, содержащая `char DisplayChar`, `bool IsWall`, и опционально `ResourceTile Resource`). Или использовать два параллельных массива: `char[,] _displayMap` и `ResourceTile[,] _resourceMap`. Предпочтительнее использовать объект `MapCell` для каждого тайла.
    *   **Алгоритм генерации:** Простой алгоритм случайного размещения: заполнить большинство тайлов "пустотой" ('.'), затем случайным образом разместить "стены" ('#') и различные ресурсные тайлы (экземпляры `ResourceTile`).
    *   Модифицировать `IsWall()` и `Draw()` для работы с новой структурой карты.
*   **Назначение:** Создание динамического и разнообразного игрового мира, подготовка к механике добычи.

**Шаг 3: Система инвентаря**
*   **Действие:** Создать `Inventory.cs` и модифицировать `Player.cs`.
*   **Изменения в `Inventory.cs` (новый файл):**
    *   Создать класс `Inventory`, содержащий `Dictionary<string, int> resources` для хранения количества каждого типа ресурса (например, "Stone": 5, "Iron": 2).
    *   Методы: `AddItem(string resourceType, int count)`, `RemoveItem(string resourceType, int count)`, `HasItem(string resourceType, int count)`.
*   **Изменения в `Player.cs`:**
    *   Добавить свойство `public Inventory PlayerInventory { get; private set; }`.
    *   Инициализировать `PlayerInventory` в конструкторе.
*   **Назначение:** Предоставление игроку возможности собирать и хранить ресурсы.

**Шаг 4: Действия "добычи" и "строительства"**
*   **Действие:** Модифицировать `Player.cs` и `GameMap.cs`.
*   **Изменения в `Player.cs`:**
    *   Добавить метод `Mine(GameMap map)`:
        *   Получает тайл по текущей позиции игрока.
        *   Если это `ResourceTile`, уменьшает его `Health`.
        *   Если `Health` достигает 0, добавляет `ResourceType` в `PlayerInventory`, заменяет тайл на '.' в `GameMap`.
    *   Добавить метод `Build(GameMap map, string resourceType)`:
        *   Проверяет `PlayerInventory` на наличие `resourceType`.
        *   Если есть, уменьшает количество `resourceType` в инвентаре.
        *   Заменяет текущий тайл на карте на соответствующий строительный блок (например, '#').
*   **Изменения в `GameMap.cs`:**
    *   Добавить методы `GetTile(int x, int y)` и `SetTile(int x, int y, MapCell newCell)` для доступа и модификации тайлов.
*   **Обработка ввода в `ManualPlayerController.cs`:**
    *   Добавить обработку новых клавиш (например, `KEY_M` для добычи, `KEY_B` для строительства).
    *   Вызывать `player.Mine()` или `player.Build()` соответственно.
*   **Назначение:** Расширение интерактивности игрока с миром.

**Шаг 5: Простейший HUD для инвентаря**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения в `Program.cs`:**
    *   Добавить логику отрисовки инвентаря игрока (из `player.PlayerInventory`) в углу экрана.
*   **Назначение:** Визуализация состояния инвентаря игрока.

**Шаг 6: Расширенный ИИ-контроллер**
*   **Действие:** Модифицировать `AIPlayerController.cs`.
*   **Изменения в `AIPlayerController.cs`:**
    *   Расширить логику `Update()` для выполнения не только движения, но и:
        *   **Исследование:** Продолжать двигаться случайным образом.
        *   **Добыча:** Если ИИ находится рядом с `ResourceTile` с `Health > 0`, он должен пытаться "добывать" его.
        *   **Строительство:** Если у ИИ есть ресурсы в инвентаре, он может принимать решение о строительстве (например, построить случайную стену рядом с собой).
    *   Реализовать базовую логику принятия решений (например, приоритет: добыть ресурс, затем построить, затем исследовать).
    *   **Видимость действий:** Возможно, выводить текстовые сообщения в HUD о действиях ИИ, или изменять цвет персонажа ИИ в момент действия.
*   **Назначение:** Создание увлекательного автономного игрового процесса.

**Шаг 7: Обновление тестов**
*   **Действие:** Создать новые тестовые файлы и/или модифицировать существующие.
*   **Тесты для `ResourceTile`:** Проверка создания и свойств.
*   **Тесты для `Inventory`:** Проверка добавления/удаления ресурсов.
*   **Тесты для `Player` (методы Mine/Build):** Проверка корректности добычи и строительства.
*   **Тесты для `GameMap` (генерация и модификация):** Проверка генерации карты и изменения тайлов.
*   **Тесты для `AIPlayerController`:** Проверка, что ИИ выполняет новые действия.
*   **Назначение:** Обеспечение качества кода нового функционала.

---

**Статус разработки**

*   **Версия 0.01:** Завершена.
*   **Версия 0.02:** Завершена.
*   **Версия 0.03:** Завершена.
