# План разработки версии 0.01

## Цель
Разработать прототип ASCII-игры на C# с использованием библиотеки Raylib.

## Этапы разработки:

1.  **Инициализация проекта и настройка Raylib:**
    *   Создание нового консольного проекта C#.
    *   Установка и настройка библиотеки Raylib (через NuGet-пакет `Raylib-cs`).

2.  **Создание базового окна игры:**
    *   Инициализация окна Raylib с заданными размерами и заголовком.

3.  **Реализация основного игрового цикла:**
    *   Обработка событий (ввод пользователя).
    *   Обновление состояния игры.
    *   Отрисовка игровых элементов.

4.  **Настройка отрисовки базовой ASCII-графики:**
    *   Использование шрифтов, способных отображать ASCII-символы.
    *   Отрисовка символов и строк с заданными координатами и цветом.

5.  **Создание и отображение персонажа игрока:**
    *   Определение класса/структуры для персонажа игрока (позиция, символ, цвет).
    *   Отрисовка персонажа на экране.

6.  **Реализация обработки ввода с клавиатуры для перемещения персонажа:**
    *   Обработка нажатий клавиш (например, стрелки или WASD) для изменения позиции персонажа.

7.  **Создание простой статической карты с использованием ASCII-символов:**
    *   Определение структуры данных для карты (например, двумерный массив символов).
    *   Отрисовка карты на экране.

8.  **Реализация базового обнаружения столкновений персонажа с картой:**
    *   Проверка возможности перемещения персонажа в новую позицию на основе карты (например, нельзя пройти сквозь 'стены').

---

# План разработки версии 0.02: Внедрение ИИ-управления и переключения режимов

**Цель:** Добавить в игру возможность управления персонажем с помощью искусственного интеллекта (ИИ), а также предоставить пользователю механизм для переключения между ручным управлением и автоматическим управлением ИИ.

**Ключевые особенности версии 0.02:**
*   Возможность игрового ИИ брать на себя управление персонажем.
*   Сохранение функциональности ручного управления.
*   Механизм переключения между ручным и ИИ-управлением во время игры.

---

### Подробный план реализации:

**Шаг 1: Определение интерфейса контроллера**
*   **Действие:** Создать новый файл `IPlayerController.cs`.
*   **Содержимое:** Определить интерфейс `IPlayerController` с единственным методом:
    ```csharp
    public interface IPlayerController
    {
        void Update(Player player, GameMap map);
    }
    ```
*   **Назначение:** Этот интерфейс позволит унифицировать взаимодействие с различными типами контроллеров (ручным и ИИ) в игровом цикле.

**Шаг 2: Реализация ручного контроллера**
*   **Действие:** Создать новый файл `ManualPlayerController.cs`.
*   **Содержимое:** Создать класс `ManualPlayerController`, который реализует `IPlayerController`. В его методе `Update` будет инкапсулирована текущая логика обработки ввода с клавиатуры для перемещения игрока.
*   **Назначение:** Отделение логики ручного управления от основного игрового цикла и соответствие модульной структуре.

**Шаг 3: Реализация контроллера ИИ**
*   **Действие:** Создать новый файл `AIPlayerController.cs`.
*   **Содержимое:** Создать класс `AIPlayerController`, который также реализует `IPlayerController`. В его методе `Update` будет реализована базовая логика ИИ.
    *   **Первая итерация логики ИИ:** Простое случайное движение. ИИ будет случайным образом выбирать одно из четырех направлений (вверх, вниз, влево, вправо) и пытаться переместить игрока, проверяя наличие стен на `GameMap`.
    *   **Механизм задержки:** Добавить небольшую задержку между действиями ИИ (например, движение раз в 10-20 кадров), чтобы его действия не были слишком быстрыми и хаотичными.
*   **Назначение:** Внедрение автономного управления персонажем с помощью ИИ.

**Шаг 4: Модификация основного игрового цикла (`Program.cs`)**
*   **Действие:** Изменить существующий файл `Program.cs`.
*   **Изменения:**
    *   Создать экземпляры `ManualPlayerController` и `AIPlayerController`.
    *   Объявить переменную `IPlayerController currentController`, которая будет указывать на активный контроллер (по умолчанию `ManualPlayerController`).
    *   Добавить логику для обработки новой клавиши (например, `KeyboardKey.KEY_A` или `KeyboardKey.KEY_SPACE`) для переключения значения `currentController` между `ManualPlayerController` и `AIPlayerController`.
    *   В основном игровом цикле `while (!Raylib.WindowShouldClose())` удалить прямую обработку ввода игрока и вместо этого вызывать `currentController.Update(player, gameMap)`.
*   **Назначение:** Интеграция нового подхода к управлению и предоставление пользователю возможности переключения режимов.

**Шаг 5: Обновление класса `Player.cs` (если потребуется)**
*   **Действие:** Провести ревизию `Player.cs`.
*   **Изменения:** Внести изменения только в случае, если выявятся новые требования или оптимизации, связанные с интеграцией контроллеров. На текущий момент ожидается, что изменения не потребуются.

**Шаг 6: Разработка и запуск тестов**
*   **Действие:** Создать новые тестовые файлы и добавить в них юнит-тесты.
*   **Тесты для `ManualPlayerController`:**
    *   `tests/GGD.Tests/ManualPlayerControllerTests.cs`
    *   Проверить, что контроллер корректно обрабатывает различные нажатия клавиш и вызывает метод `player.Move` с соответствующими параметрами.
*   **Тесты для `AIPlayerController`:**
    *   `tests/GGD.Tests/AIPlayerControllerTests.cs`
    *   Проверить, что ИИ-контроллер пытается переместить игрока (можно использовать заглушки или моки для `Player` и `GameMap`).
    *   Убедиться, что ИИ не пытается пройти сквозь стены, используя информацию от `GameMap`.
*   **Назначение:** Обеспечение качества кода и корректности работы нового функционала.

---

### Решение проблем с тестами (важные исправления)
*   **Обновление синтаксиса NUnit `Assert`:** В NUnit версии 4.2 (и выше) статические методы `Assert.AreEqual` и `Assert.AreNotEqual` были удалены. Они были заменены на более гибкий синтаксис с использованием `Assert.That(actual, Is.EqualTo(expected))` и `Assert.That(actual, Is.Not.EqualTo(expected))`. Все вызовы `Assert.AreEqual` и `Assert.AreNotEqual` в `ManualPlayerControllerTests.cs` и `AIPlayerControllerTests.cs` были заменены на новый синтаксис.
*   **Корректировка размера карты в `GameMap.cs`:** Исходный размер карты в `GameMap.cs` (40x20) не соответствовал предположениям существующих тестов, которые рассчитывали на карту 20x10. Размеры `_mapWidth` и `_mapHeight` в `GameMap.cs` были уменьшены до 20 и 10 соответственно, чтобы обеспечить корректную работу граничных проверок в тестах.

---

**Завершение:**
После успешного выполнения всех шагов и прохождения тестов, версия 0.02 будет готова.

---

# План разработки версии 0.03: Процедурная генерация мира, ресурсы и базовое строительство

**Цель:** Заложить фундамент для Minecraft-подобной механики, позволив игроку исследовать процедурно генерируемый мир, добывать ресурсы и использовать их для базового строительства. Расширить возможности ИИ-контроллера для взаимодействия с этими новыми механиками.

**Ключевые особенности версии 0.03:**
*   Процедурно генерируемая карта с различными типами тайлов (ресурсами).
*   Система инвентаря для хранения ресурсов.
*   Действия игрока: "добыча" ресурсов и "строительство" блоков.
*   Простейший HUD для отображения инвентаря.
*   Расширенный ИИ-контроллер, способный выполнять действия добычи и строительства, а также видимость его действий.
*   Возможность изменения размера окна и полноэкранного режима игры.

---

### Подробный план реализации:

**Шаг 1: Возможность изменения размера окна и полноэкранного режима**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения:**
    *   Установить флаг `Raylib_cs.ConfigFlags.FLAG_WINDOW_RESIZABLE` при инициализации окна.
    *   Реализовать логику переключения полноэкранного режима по нажатию клавиши `F11` (используя `Raylib.ToggleFullscreen()`, `Raylib.GetMonitorWidth()`, `Raylib.GetMonitorHeight()`, `Raylib.SetWindowSize()`).
    *   Реализовать динамический расчет `charSize` в цикле отрисовки, чтобы размер символов масштабировался в соответствии с размером окна (например, `charSize = screenHeight / GameMap.MapHeight`).
*   **Назначение:** Улучшение пользовательского опыта, адаптация игры к различным разрешениям экрана.

**Шаг 2: Процедурная генерация карты**
*   **Действие:** Модифицировать `GameMap.cs` и создать `ResourceTile.cs`.
*   **Изменения в `ResourceTile.cs` (новый файл):**
    *   Создать класс `ResourceTile` с публичными свойствами: `char DisplayChar`, `Raylib_cs.Color TileColor`, `string ResourceType` (например, "Stone", "Iron", "Wood"), `int Health` (сколько "ударов" нужно для добычи).
*   **Изменения в `GameMap.cs`:**
    *   Сделать `_mapWidth` и `_mapHeight` публичными статическими константами (`public const int MapWidth`, `public const int MapHeight`).
    *   Удалить метод `InitializeMap()`, который создает статическую карту.
    *   Создать новый метод `GenerateMap()`, который будет процедурно генерировать карту.
    *   Изменить внутреннее хранилище карты: вместо `char[,] _map` использовать `MapCell[,] _mapCells` (где `MapCell` - новый класс/структура, содержащая `char DisplayChar`, `bool IsWall`, и опционально `ResourceTile Resource`). Или использовать два параллельных массива: `char[,] _displayMap` и `ResourceTile[,] _resourceMap`. Предпочтительнее использовать объект `MapCell` для каждого тайла.
    *   **Алгоритм генерации:** Простой алгоритм случайного размещения: заполнить большинство тайлов "пустотой" ('.'), затем случайным образом разместить "стены" ('#') и различные ресурсные тайлы (экземпляры `ResourceTile`).
    *   Модифицировать `IsWall()` и `Draw()` для работы с новой структурой карты.
*   **Назначение:** Создание динамического и разнообразного игрового мира, подготовка к механике добычи.

**Шаг 3: Система инвентаря**
*   **Действие:** Создать `Inventory.cs` и модифицировать `Player.cs`.
*   **Изменения в `Inventory.cs` (новый файл):**
    *   Создать класс `Inventory`, содержащий `Dictionary<string, int> resources` для хранения количества каждого типа ресурса (например, "Stone": 5, "Iron": 2).
    *   Методы: `AddItem(string resourceType, int count)`, `RemoveItem(string resourceType, int count)`, `HasItem(string resourceType, int count)`.
*   **Изменения в `Player.cs`:**
    *   Добавить свойство `public Inventory PlayerInventory { get; private set; }`.
    *   Инициализировать `PlayerInventory` в конструкторе.
*   **Назначение:** Предоставление игроку возможности собирать и хранить ресурсы.

**Шаг 4: Действия "добычи" и "строительства"**
*   **Действие:** Модифицировать `Player.cs` и `GameMap.cs`.
*   **Изменения в `Player.cs`:**
    *   Добавить метод `Mine(GameMap map)`:
        *   Получает тайл по текущей позиции игрока.
        *   Если это `ResourceTile`, уменьшает его `Health`.
        *   Если `Health` достигает 0, добавляет `ResourceType` в `PlayerInventory`, заменяет тайл на '.' в `GameMap`.
    *   Добавить метод `Build(GameMap map, string resourceType)`:
        *   Проверяет `PlayerInventory` на наличие `resourceType`.
        *   Если есть, уменьшает количество `resourceType` в инвентаре.
        *   Заменяет текущий тайл на карте на соответствующий строительный блок (например, '#').
*   **Изменения в `GameMap.cs`:**
    *   Добавить методы `GetTile(int x, int y)` и `SetTile(int x, int y, MapCell newCell)` для доступа и модификации тайлов.
*   **Обработка ввода в `ManualPlayerController.cs`:**
    *   Добавить обработку новых клавиш (например, `KEY_M` для добычи, `KEY_B` для строительства).
    *   Вызывать `player.Mine()` или `player.Build()` соответственно.
*   **Назначение:** Расширение интерактивности игрока с миром.

**Шаг 5: Простейший HUD для инвентаря**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения в `Program.cs`:**
    *   Добавить логику отрисовки инвентаря игрока (из `player.PlayerInventory`) в углу экрана.
*   **Назначение:** Визуализация состояния инвентаря игрока.

**Шаг 6: Расширенный ИИ-контроллер**
*   **Действие:** Модифицировать `AIPlayerController.cs`.
*   **Изменения в `AIPlayerController.cs`:**
    *   Расширить логику `Update()` для выполнения не только движения, но и:
        *   **Исследование:** Продолжать двигаться случайным образом.
        *   **Добыча:** Если ИИ находится рядом с `ResourceTile` с `Health > 0`, он должен пытаться "добывать" его.
        *   **Строительство:** Если у ИИ есть ресурсы в инвентаре, он может принимать решение о строительстве (например, построить случайную стену рядом с собой).
    *   Реализовать базовую логику принятия решений (например, приоритет: добыть ресурс, затем построить, затем исследовать).
    *   **Видимость действий:** Возможно, выводить текстовые сообщения в HUD о действиях ИИ, или изменять цвет персонажа ИИ в момент действия.
*   **Назначение:** Создание увлекательного автономного игрового процесса.

**Шаг 7: Обновление тестов**
*   **Действие:** Создать новые тестовые файлы и/или модифицировать существующие.
*   **Тесты для `ResourceTile`:** Проверка создания и свойств.
*   **Тесты для `Inventory`:** Проверка добавления/удаления ресурсов.
*   **Тесты для `Player` (методы Mine/Build):** Проверка корректности добычи и строительства.
*   **Тесты для `GameMap` (генерация и модификация):** Проверка генерации карты и изменения тайлов.
*   **Тесты для `AIPlayerController`:** Проверка, что ИИ выполняет новые действия.
*   **Назначение:** Обеспечение качества кода нового функционала.



---

# План разработки версии 0.04: Большой мир и "умный" ИИ

**Цель:** Сделать игровой мир более масштабным и интересным для исследования, а поведение ИИ — более осмысленным и целенаправленным.

**Ключевые особенности версии 0.04:**
*   Значительно увеличенный размер карты.
*   Реализация "камеры", следующей за игроком.
*   ИИ с целеполаганием (поиск ресурсов).
*   ИИ, использующий поиск пути (A*) для навигации.

---

### Подробный план реализации:

**Шаг 1: Увеличение мира и реализация камеры**
*   **Действие:** Модифицировать `GameMap.cs` и `Program.cs`.
*   **Изменения в `GameMap.cs`:**
    *   Увеличить константы `MapWidth` и `MapHeight` (например, до 80x30).
*   **Изменения в `Program.cs`:**
    *   Ввести понятие "камеры" (координаты `cameraX`, `cameraY`), которая определяет видимую область карты.
    *   В основном цикле обновлять позицию камеры так, чтобы игрок оставался в центре экрана.
    *   Реализовать "зажимы" (clamping) для камеры, чтобы она не выходила за пределы карты.
    *   Полностью переписать логику отрисовки `GameMap` и `Player`. Вместо отрисовки всей карты, отрисовывать только видимую часть, основываясь на положении камеры. Позиции игрока и тайлов на экране будут рассчитываться относительно камеры.
*   **Назначение:** Создание ощущения большого, бесшовного мира, который можно исследовать.

**Шаг 2: Реализация "умного" ИИ с поиском пути**
*   **Действие:** Модифицировать `AIPlayerController.cs` и, возможно, создать новый класс для алгоритма A*.
*   **Изменения в `AIPlayerController.cs`:**
    *   Изменить логику принятия решений. Вместо случайного движения, ИИ будет действовать по следующему алгоритму:
        1.  Проверить, есть ли ресурсы ("Stone") в инвентаре.
        2.  Если ресурсов нет, найти на карте ближайший `ResourceTile` типа "Stone".
        3.  Если ресурс найден, использовать алгоритм поиска пути (A*) для построения маршрута от текущей позиции ИИ до ресурса.
        4.  Двигаться к цели по построенному маршруту.
        5.  Если ИИ уже на клетке с ресурсом, он начинает его добывать (как и раньше).
        6.  Если ресурсы в инвентаре есть, ИИ может вернуться к случайному строительству или исследованию.
*   **Новый класс (опционально):** `Pathfinder.cs`. Может содержать статическую реализацию алгоритма A*, принимающую карту, начальную и конечную точки, и возвращающую список узлов-координат.
*   **Назначение:** Превратить ИИ из хаотично движущегося объекта в "умного" агента, который может ставить цели и достигать их, что делает его поведение гораздо более интересным для наблюдения.

**Шаг 3: Обновление тестов**
*   **Действие:** Модифицировать тесты для `AIPlayerController`.
*   **Изменения:**
    *   Создать тесты, которые проверяют новую логику ИИ. Например, на тестовой карте с одним ресурсом и препятствием убедиться, что ИИ строит корректный маршрут для обхода препятствия и достигает ресурса.
*   **Назначение:** Обеспечение корректной работы сложной логики поиска пути и принятия решений.

---

# План разработки версии 0.05: Дом и выживание ночью

**Цель:** Добавить в игру первый настоящий элемент выживания. Ввести цикл дня и ночи, который несет как визуальные изменения, так и геймплейные — ночью становится опасно находиться снаружи. Мотивировать игрока и ИИ строить укрытия (дома) для защиты от ночной угрозы.

**Ключевые особенности версии 0.05:**
*   Цикл смены дня и ночи.
*   Новая угроза: "холод" для тех, кто находится ночью на улице.
*   Механика определения, находится ли персонаж внутри замкнутого помещения ("дома").
*   Обновленный ИИ, который целенаправленно строит дом и прячется в нем на ночь.

---

### Подробный план реализации:

**Шаг 1: Реализация цикла дня и ночи**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения:**
    *   Ввести глобальный счетчик времени (`gameTime`), который увеличивается каждый кадр.
    *   На основе `gameTime` вычислять, является ли текущее время "днем" или "ночью" (например, с помощью операции остатка от деления).
    *   В главном цикле отрисовки изменять цвет фона в зависимости от времени суток (`Raylib.ClearBackground()`). Например, `SKYBLUE` для дня и `DARKBLUE` для ночи.
    *   Добавить на HUD текстовый индикатор текущего времени суток.
*   **Назначение:** Создание базовой механики и атмосферы для нового геймплея выживания.

**Шаг 2: Механика определения "внутри/снаружи"**
*   **Действие:** Модифицировать `GameMap.cs`.
*   **Изменения:**
    *   Создать новый публичный метод `IsInside(int x, int y)`.
    *   Реализовать в этом методе алгоритм "заливки" (flood fill) или поиска в ширину (BFS), который стартует от всех крайних клеток карты.
    *   Все клетки, достижимые от края карты, считаются "снаружи". Все остальные — "внутри".
    *   Метод будет возвращать `true`, если координаты `(x, y)` находятся внутри замкнутого контура.
*   **Назначение:** Создание надежного способа для игры понять, когда персонаж находится в укрытии.

**Шаг 3: Механика "холода" и статусы игрока**
*   **Действие:** Модифицировать `Player.cs`, `Program.cs`, `ManualPlayerController.cs` и `AIPlayerController.cs`.
*   **Изменения:**
    *   В `Player.cs` добавить новое свойство, например `public bool IsFreezing { get; set; }`.
    *   В `Program.cs` в основном цикле добавить логику: если сейчас ночь И `gameMap.IsInside(player.X, player.Y)` возвращает `false`, то установить `player.IsFreezing = true`. В противном случае `false`.
    *   В контроллерах (`ManualPlayerController` и `AIPlayerController`) проверять состояние `player.IsFreezing`. Если оно `true`, искусственно замедлять действия персонажа (например, обрабатывать движение не каждый кадр, а каждый второй).
*   **Назначение:** Введение понятного штрафа за нахождение на улице ночью, что создает мотивацию для строительства.

**Шаг 4: Обновление логики ИИ**
*   **Действие:** Существенно переработать `AIPlayerController.cs`.
*   **Изменения:**
    *   Добавить ИИ осведомленность о времени суток.
    *   Когда приближается ночь, главной целью ИИ становится поиск укрытия.
    *   **Логика поведения:**
        1.  ИИ проверяет, находится ли он уже внутри.
        2.  Если нет, ищет ближайшее существующее укрытие и движется к нему с помощью A*.
        3.  Если укрытия поблизости нет, ИИ переходит в режим строительства: находит подходящую пустую площадку, собирает ресурсы и строит простую "коробку" 3x3 или 4x4, после чего заходит внутрь.
    *   **Назначение:** Сделать поведение ИИ осмысленным и адаптивным к новым условиям выживания.

**Шаг 5: Обновление тестов**
*   **Действие:** Модифицировать существующие и добавить новые тесты.
*   **Изменения:**
    *   Создать тесты для `GameMap.IsInside()`.
    *   Написать тесты, проверяющие, что к игроку применяется эффект замедления в правильных условиях.
    *   Разработать сложные тесты для новой логики поведения ИИ.
*   **Назначение:** Обеспечение качества и корректной работы всех новых механик.

---

## Статус разработки

*   **Версия 0.01:** Завершена.
*   **Версия 0.02:** Завершена.
*   **Версия 0.03:** Завершена.
*   **Версия 0.04:** Завершена.
*   **Версия 0.05:** Завершена.
*   **Версия 0.06:** Завершена.

---

# План разработки версии 0.07: Свободная камера и улучшенный интерфейс

**Цель:** Полностью переработать взаимодействие пользователя с игровым миром, внедрив свободную камеру в стиле RTS (стратегий в реальном времени) и заложив основу для более сложного и информативного интерфейса.

**Ключевые особенности версии 0.07:**
*   **Свободная камера:** Камера больше не привязана к игроку.
*   **Масштабирование (Zoom):** Плавное изменение масштаба карты с помощью колесика мыши.
*   **Панорамирование (Pan):** Перемещение камеры путем подведения курсора мыши к краям экрана.
*   **Структурированный HUD:** Реорганизация и улучшение существующего Heads-Up Display.

---

### Подробный план реализации:

**Шаг 1: Реализация свободной камеры и панорамирования**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения:**
    *   Отвязать логику `cameraX` и `cameraY` от координат `player.X` и `player.Y`. Камера теперь будет иметь собственные координаты, независимые от игрока.
    *   В основном игровом цикле добавить новую логику:
        *   Получать текущие координаты курсора мыши (`Raylib.GetMouseX()`, `Raylib.GetMouseY()`).
        *   Определить "активные зоны" у краев экрана (например, 50 пикселей).
        *   Если курсор входит в активную зону, начать изменять `cameraX` или `cameraY` с определенной скоростью (`cameraSpeed`).
    *   Продолжать использовать "зажимы" (clamping) для камеры, чтобы она не выходила за пределы карты.
*   **Назначение:** Предоставить игроку свободу исследования карты, как в классических RTS.

**Шаг 2: Реализация масштабирования (Zoom)**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения:**
    *   Ввести новую переменную для управления масштабом, например `cameraZoom`, с начальным значением `1.0f`.
    *   В игровом цикле отслеживать изменение колесика мыши (`Raylib.GetMouseWheelMove()`).
    *   При прокрутке колесика изменять `cameraZoom` (например, увеличивать/уменьшать на 0.1f за шаг).
    *   Установить минимальное и максимальное значения для `cameraZoom`, чтобы избежать слишком сильного приближения или отдаления.
    *   Изменить логику расчета `charSize`. Вместо фиксированного размера, он теперь будет зависеть от `cameraZoom` и текущего размера окна. Это позволит динамически изменять видимую область карты.
    *   **Важно:** Масштабирование должно происходить в точку, где находится курсор мыши, а не в центр экрана. Это потребует корректировки координат камеры для создания эффекта "приближения к курсору".
*   **Назначение:** Дать игроку контроль над уровнем детализации и обзором карты.

**Шаг 3: Рефакторинг и структурирование HUD**
*   **Действие:** Модифицировать `Program.cs` и, возможно, создать новые классы для элементов интерфейса.
*   **Изменения:**
    *   **Анализ:** Текущий HUD выводит всю информацию (время, голод, инвентарь) в левом верхнем и правом верхнем углах. Это не всегда удобно.
    *   **План реорганизации:**
        1.  **Верхняя панель:** Оставить здесь только самую важную информацию о состоянии мира: время суток (возможно, с графическим индикатором), день.
        2.  **Нижняя панель:** Создать новую панель внизу экрана. Здесь будет отображаться информация о выделенном объекте. Если ничего не выделено - информация об игроке (голод, инвентарь, текущее действие).
        3.  **Панель команд:** В правой части нижней панели разместить иконки или текстовые кнопки для основных действий: "Строить", "Добывать" и т.д. Пока это будет визуальная заглушка.
    *   **Реализация:**
        *   Разделить код отрисовки HUD на отдельные функции: `DrawTopPanel()`, `DrawBottomPanel()`.
        *   Использовать `Raylib.DrawRectangle()` для создания фоновых плашек для панелей, чтобы текст был лучше читаем.
*   **Назначение:** Сделать интерфейс более читаемым, организованным и готовым к добавлению новых функций (например, выделение юнитов, приказы).

**Шаг 4: Обновление тестов**
*   **Действие:** Проанализировать существующие тесты.
*   **Изменения:**
    *   Большинство изменений в этой версии касаются `Program.cs`, который исключен из покрытия тестами (`[ExcludeFromCodeCoverage]`).
    *   Юнит-тесты для контроллеров, игрока и карты не должны быть затронуты, так как логика камеры и рендеринга вынесена из них.
    *   На данном этапе новые юнит-тесты не требуются, но необходимо убедиться, что все существующие тесты по-прежнему проходят после рефакторинга.
*   **Назначение:** Гарантировать, что изменения в рендеринге и управлении не сломали основную игровую логику.



---

# План разработки версии 0.08

**Цель:** Сделать ночной холод реальной угрозой с полноценной системой здоровья, научить ИИ строить убежища, повысить информативность интерфейса с 24-часовыми часами и настроить игровой цикл на более размеренный темп.

**Ключевые нововведения:**

1.  **Реалистичная механика холода и система здоровья:** Введение здоровья как новой основной характеристики игрока. Холод будет напрямую влиять на здоровье.
2.  **Настройка игрового времени:** Изменение длительности игровых суток: 10 минут реального времени (5 минут день, 5 минут ночь).
3.  **Реалистичная механика голода:** Снижение скорости расхода сытости, чтобы игрок мог прожить несколько игровых дней на полной шкале.
4.  **Температурная механика:** Добавление дневной и ночной температуры, с порогом, при котором игрок начинает замерзать.
5.  **ИИ-строитель:** ИИ научится самостоятельно строить простое убежище, если не сможет найти существующее.
6.  **24-часовые часы:** В интерфейс будет добавлено точное время в 24-часовом формате.

**Подробный план реализации:**

**Шаг 1: Настройка игрового времени и реалистичный голод**
*   **Действие:** Модифицировать `Program.cs` и `Player.cs`.
*   **Изменения в `Program.cs`:**
    *   Изменить константы `DayDuration` и `NightDuration` на `18000` кадров каждую (по 5 минут реального времени), чтобы `TotalDayNightDuration` стал `36000` кадров (10 реальных минут).
*   **Изменения в `Player.cs`:**
    *   Изменить константу `HungerDecayInterval` на `1080` кадров (чтобы сытость расходовалась примерно за 3 игровых дня).

**Шаг 2: Внедрение системы здоровья и урона от холода**
*   **Действие:** Модифицировать `Player.cs` и `Program.cs`.
*   **Изменения в `Player.cs`:**
    *   Добавить новые свойства: `public int Health { get; private set; }` и `public const int MaxHealth = 100;`.
    *   Добавить приватный счетчик `_healthDecayCounter` для урона от холода.
    *   В метод `UpdateHunger()` (или новый `UpdateSurvivalStats()`) добавить логику:
        *   Если `IsFreezing` равно `true`, игрок будет терять `Health` (например, 1 ед. каждые 2-3 секунды реального времени, для этого понадобится константа `FreezeDamageInterval`).
        *   Если `Health` падает до 0, игрок "погибает".
    *   Добавить методы `TakeDamage(int amount)` и `RestoreHealth(int amount)`.
    *   Реализовать медленное восстановление здоровья, если игрок сыт и находится в тепле.
*   **Изменения в `Program.cs`:**
    *   В `DrawTopPanel` добавить отображение нового статуса здоровья.

**Шаг 3: Температурная механика**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения в `Program.cs`:**
    *   Ввести константы для дневной (`DayTemperature`) и ночной (`NightTemperature`) температуры (например, `DayTemperature = 20`, `NightTemperature = -5`).
    *   Ввести константу для порога замерзания (`FreezingThresholdTemperature = 0`).
    *   Ввести переменную `currentTemperature`.
    *   Реализовать плавное изменение `currentTemperature` между `DayTemperature` и `NightTemperature` в течение игровых суток.
    *   Изменить логику `player.IsFreezing`: теперь она будет зависеть от `currentTemperature < FreezingThresholdTemperature` и того, находится ли игрок на улице.
    *   В `DrawTopPanel` добавить отображение текущей температуры.

**Шаг 4: ИИ-строитель**
*   **Действие:** Полностью переработать/дополнить `AIPlayerController.cs`.
*   **Изменения:**
    *   Добавить новую цель (`BuildShelter`), которая будет активироваться, если ИИ не находит укрытия перед ночью.
    *   Логика `BuildShelter`: поиск места, сбор ресурсов (`Stone`), постройка стен и двери.

**Шаг 5: 24-часовые часы**
*   **Действие:** Модифицировать `Program.cs`.
*   **Изменения:**
    *   На основе `gameTime` рассчитать текущие час и минуту в 24-часовом формате.
    *   В методе `DrawTopPanel` вывести отформатированное время.

**Шаг 6: Обновление `PLAN.md` и тестов**
*   Внести утвержденный план в `PLAN.md`.
*   Добавить/обновить тесты для `Player.cs`, `AIPlayerController.cs`.



---

## Статус разработки

*   **Версия 0.01:** Завершена.
*   **Версия 0.02:** Завершена.
*   **Версия 0.03:** Завершена.
*   **Версия 0.04:** Завершена.
*   **Версия 0.05:** Завершена.
*   **Версия 0.06:** Завершена.
*   **Версия 0.07:** Завершена.
*   **Версия 0.08:** Завершена (холод, здоровье, температура и 24-часовой HUD).
